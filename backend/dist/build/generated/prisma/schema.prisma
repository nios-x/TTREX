generator client {
  provider = "prisma-client-js"
  output   = "../src/build/generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id           String        @id @default(cuid())
  email        String        @unique
  password     String
  firstName    String?
  lastName     String?
  createdAt    DateTime      @default(now())
  wallets      Wallet[]      @relation("UserWallets")
  properties   Property[]    @relation("OwnerProperties")
  proposals    Proposal[]    @relation("UserProposals")
  listings     Listing[]     @relation("UserListings")
  transactions Transaction[] @relation("UserTransactions")
}

model Wallet {
  id            String         @id @default(cuid())
  address       String         @unique
  user          User           @relation("UserWallets", fields: [userId], references: [id])
  userId        String
  assets        Asset[]        @relation("WalletAssets")
  fractions     Fraction[]     @relation("WalletFractions")
  transactions  Transaction[]  @relation("WalletTransactions")
  payments      Payment[]      @relation("WalletPayments")
  createdAt     DateTime       @default(now())
  sellProposals SellProposal[] @relation("WalletSellProposals") // proposals created by this wallet
}

model Payment {
  id           String   @id @default(cuid())
  property     Property @relation(fields: [propertyId], references: [id])
  propertyId   String
  fromWallet   Wallet   @relation("WalletPayments", fields: [fromWalletId], references: [id]) // <-- specify relation name
  fromWalletId String
  amount       Float
  distributed  Boolean  @default(false)
  createdAt    DateTime @default(now())
}

model Transaction {
  id         String    @id @default(cuid())
  user       User?     @relation("UserTransactions", fields: [userId], references: [id])
  userId     String?
  wallet     Wallet    @relation("WalletTransactions", fields: [walletId], references: [id])
  walletId   String
  propertyId String?
  fractionId String?
  fraction   Fraction? @relation("FractionTransactions", fields: [fractionId], references: [id])
  type       TxType
  amount     Float
  hash       String
  createdAt  DateTime  @default(now())
}

/// ASSETS OWNED BY A WALLET
model Asset {
  id          String   @id @default(cuid())
  type        String // e.g., "PropertyFraction", "NFT"
  referenceId String // ID of Property, Fraction, etc.
  wallet      Wallet   @relation("WalletAssets", fields: [walletId], references: [id])
  walletId    String
  createdAt   DateTime @default(now())
}

/// PROPERTY MODEL
model Property {
  id            String         @id @default(cuid())
  title         String
  description   String
  valuation     Float
  nftAddress    String // ERC721 contract address
  owner         User           @relation("OwnerProperties", fields: [ownerId], references: [id])
  ownerId       String
  fractions     Fraction[]     @relation("PropertyFractions")
  imageUrl      String
  status        PropertyStatus @default(PENDING)
  tokenId       String
  createdAt     DateTime       @default(now())
  proposals     Proposal[]     @relation("PropertyProposals")
  payments      Payment[]
  listings      Listing[]      @relation("PropertyListings")
  sellProposals SellProposal[] @relation("PropertySellProposals")
}

/// FRACTION MODEL
model Fraction {
  id            String         @id @default(cuid())
  property      Property       @relation("PropertyFractions", fields: [propertyId], references: [id])
  propertyId    String
  owner         Wallet         @relation("WalletFractions", fields: [walletId], references: [address])
  walletId      String
  supply        Int
  createdAt     DateTime       @default(now())
  transactions  Transaction[]  @relation("FractionTransactions")
  sellProposals SellProposal[] @relation("FractionSellProposals")
}

model SellProposal {
  id            String   @id @default(cuid())
  property      Property @relation("PropertySellProposals", fields: [propertyId], references: [id])
  propertyId    String
  fraction      Fraction @relation("FractionSellProposals", fields: [fractionId], references: [id])
  fractionId    String
  creatorWallet Wallet   @relation("WalletSellProposals", fields: [walletId], references: [id])
  walletId      String
  shardsForSale Int
  pricePerShard Float
  remaining     Int
  executed      Boolean  @default(false)
  buyers        Json     @default("[]") // track buyers optionally
  createdAt     DateTime @default(now())
}

/// PROPOSAL MODEL
model Proposal {
  id          String   @id @default(cuid())
  property    Property @relation("PropertyProposals", fields: [propertyId], references: [id])
  propertyId  String
  creator     User     @relation("UserProposals", fields: [creatorId], references: [id])
  creatorId   String
  title       String
  description String
  votes       Json     @default("[]") // Array of {voterAddress, vote}
  executed    Boolean  @default(false)
  createdAt   DateTime @default(now())
}

/// LISTING MODEL
model Listing {
  id         String   @id @default(cuid())
  property   Property @relation("PropertyListings", fields: [propertyId], references: [id])
  propertyId String
  seller     User     @relation("UserListings", fields: [sellerId], references: [id])
  sellerId   String
  amount     Int
  price      Float
  active     Boolean  @default(true)
  createdAt  DateTime @default(now())
}

model PendingUser {
  id        String   @id @default(cuid())
  email     String   @unique
  password  String
  firstName String?
  lastName  String?
  otp       String
  createdAt DateTime @default(now())
}

model PasswordReset {
  id        String   @id @default(cuid())
  email     String   @unique
  otp       String
  createdAt DateTime @default(now())
}

/// ENUMS
enum PropertyStatus {
  PENDING
  VERIFIED
  FRACTIONALISED
  SOLD
}

enum TxType {
  BUY
  SELL
  FRACTIONALISE
  UNLOCK
}

/// Simple key-value mapping between DB IDs and on-chain token IDs
model TokenMapping {
  id        String   @id @default(cuid()) // internal DB ID
  dbId      String // the DB-generated ID (Property or Fraction)
  tokenId   Int // corresponding on-chain ERC1155 tokenId
  createdAt DateTime @default(now())
}
